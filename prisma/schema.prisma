generator client {
  provider      = "prisma-client-js"
  output        = "../node_modules/.prisma/client"
  binaryTargets = ["native", "debian-openssl-3.0.x", "linux-arm64-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @db.Uuid
  email     String   @unique
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("users")
}

model Campus {
  id        String    @id @db.Uuid
  code      String    @unique
  nameTh    String?   @map("name_th")
  nameEn    String?   @map("name_en")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  courses   Course[]
  faculties Faculty[]

  @@index([id], name: "campus_id_index")
  @@map("campuses")
}

model Faculty {
  id        String   @id @db.Uuid
  code      String
  nameTh    String?  @map("name_th")
  nameEn    String?  @map("name_en")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  campusId  String   @map("campus_id") @db.Uuid
  campus    Campus   @relation(fields: [campusId], references: [id])
  courses   Course[]

  @@unique([campusId, code], name: "unique_campus_faculty_code")
  @@index([id], name: "faculty_id_index")
  @@map("faculties")
}

model Course {
  id          String   @id @db.Uuid
  campusId    String   @map("campus_id") @db.Uuid
  campus      Campus   @relation(fields: [campusId], references: [id])
  facultyId   String   @map("faculty_id") @db.Uuid
  faculty     Faculty  @relation(fields: [facultyId], references: [id])
  // unique bcz
  subjectCode String   @unique @map("subject_code")
  subjectName String   @map("subject_name")
  isGenEd     Boolean  @default(false) @map("is_gen_ed")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  metadata    Json?

  courseLearningOutcomes CourseLearningOutcome[]
  courseOfferings        CourseOffering[]
  courseClickLogs        CourseClickLog[]

  @@map("courses")
}

model CourseOffering {
  id           String   @id @db.Uuid
  courseId     String   @map("course_id") @db.Uuid
  course       Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  semester     Int
  academicYear Int      @map("academic_year")
  createdAt    DateTime @default(now()) @map("created_at")

  @@unique([courseId, semester, academicYear], name: "unique_course_offering")
  @@map("course_offerings")
}

model CourseLearningOutcome {
  id               String                       @id @db.Uuid
  cloNo            Int                          @map("clo_no")
  originalCloName  String                       @map("original_clo_name")
  cleanedCloName   String                       @map("cleaned_clo_name_th")
  courseId         String                       @map("course_id") @db.Uuid
  course           Course                       @relation(fields: [courseId], references: [id], onDelete: Cascade)
  vectorId         String?                      @map("vector_id") @db.Uuid
  vector           CourseLearningOutcomeVector? @relation(fields: [vectorId], references: [id], onDelete: SetNull)
  skipEmbedding    Boolean                      @default(false) @map("skip_embedding")
  hasEmbedding768  Boolean                      @default(false) @map("has_embedding_768")
  hasEmbedding1536 Boolean                      @default(false) @map("has_embedding_1536")
  createdAt        DateTime                     @default(now()) @map("created_at")
  updatedAt        DateTime                     @updatedAt @map("updated_at")

  @@unique([courseId, cloNo], name: "unique_course_clo")
  // allow duplicate CLO names within the same course offering, not affected to vectoring
  @@map("course_learning_outcomes")
}

model CourseLearningOutcomeVector {
  id                     String                       @id @db.Uuid
  embeddedText           String                       @unique @map("embedded_text")
  embedding768           Unsupported("vector(768)")?  @map("embedding_768")
  embedding1536          Unsupported("vector(1536)")? @map("embedding_1536")
  metadata               Json?
  createdAt              DateTime                     @default(now()) @map("created_at")
  courseLearningOutcomes CourseLearningOutcome[]

  @@map("course_learning_outcome_vectors")
}

model CourseClickLog {
  id         String      @id @db.Uuid
  questionId String      @map("question_id") @db.Uuid
  course     Course      @relation(fields: [courseId], references: [id])
  courseId   String      @map("course_id") @db.Uuid
  question   QuestionLog @relation(fields: [questionId], references: [id])
  createdAt  DateTime    @default(now()) @map("created_at")

  @@unique([questionId, courseId], name: "unique_question_course_click")
}

// unused models for now.

enum QueryStatus {
  PENDING
  COMPLETED
  EARLY_EXIT // Query exited early (irrelevant/dangerous classification)
  FAILED
  TIMEOUT

  @@map("query_status")
}

model QueryProcessLog {
  id       String      @id @db.Uuid
  status   QueryStatus @default(PENDING)
  question String

  // JSONB fields - flexible, no migration needed for new fields
  input    Json? // Query input parameters
  output   Json? // Final results (answer, courses, classification)
  metrics  Json? // Aggregated metrics (duration, tokens, cost, counts)
  metadata Json? // Additional data (sessionId, userId, etc.)
  error    Json? // Error info (code, message, stack)

  // Computed scalar fields for efficient filtering and sorting
  // Populated at write time from metrics JSONB data
  totalDuration   Int?     @map("total_duration")   // Total duration in milliseconds
  totalTokens     Int?     @map("total_tokens")     // Total tokens used (LLM + embedding)
  totalCost       Decimal? @db.Decimal(10, 6) @map("total_cost") // Total cost in USD

  // Timestamps
  startedAt   DateTime  @default(now()) @map("started_at")
  completedAt DateTime? @map("completed_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  processSteps QueryProcessStep[]

  @@index([status])
  @@index([startedAt])
  @@index([totalCost])
  @@index([totalDuration])
  @@index([totalTokens])
  @@map("query_process_logs")
}

model QueryProcessStep {
  id         String          @id @db.Uuid
  queryLogId String          @map("query_log_id") @db.Uuid
  processLog QueryProcessLog @relation(fields: [queryLogId], references: [id], onDelete: Cascade)

  // Core fields (for indexing)
  stepName  String @map("step_name")
  stepOrder Int    @map("step_order")

  // JSONB fields - flexible storage
  input     Json? // Input data for this step
  output    Json? // Output data from this step
  llm       Json? // LLM config (provider, model, version, params, tokens, cost)
  embedding Json? // Embedding config (model, provider, dimension, etc.) - for COURSE_RETRIEVAL step
  metrics   Json? // Timing, duration
  error     Json? // Error info (code, message, details)

  // Timestamps
  startedAt   DateTime  @default(now()) @map("started_at")
  completedAt DateTime? @map("completed_at")
  duration    Int?      @map("duration") // milliseconds
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  @@index([queryLogId])
  @@index([stepName])
  @@index([startedAt])
  @@map("query_process_steps")
}

model QuestionLog {
  id                  String                @id @db.Uuid
  questionText        String                @map("question_text")
  role                String?
  metadata            Json?
  createdAt           DateTime              @default(now()) @map("created_at")
  relatedProcessLogId String?               @map("related_process_log_id") @db.Uuid
  courseClickLogs     CourseClickLog[]
  analyses            QuestionLogAnalysis[]

  @@index([createdAt])
  @@index([relatedProcessLogId])
  @@map("question_logs")
}

model QuestionLogAnalysis {
  id            String      @id @db.Uuid
  questionLogId String      @map("question_log_id") @db.Uuid
  questionLog   QuestionLog @relation(fields: [questionLogId], references: [id], onDelete: Cascade)

  extractionVersion String   @map("extraction_version")
  extractionNumber  Int      @map("extraction_number")
  modelUsed         String   @map("model_used")
  extractedAt       DateTime @default(now()) @map("extracted_at")

  overallQuality String @map("overall_quality")
  entityCounts   Json?  @map("entity_counts")

  extractionCost Decimal @map("extraction_cost")
  tokensUsed     Int     @map("tokens_used")

  reasoning String?  @map("reasoning")
  llm       Json?    @map("llm_metadata")
  createdAt DateTime @default(now()) @map("created_at")

  entities ExtractedEntity[]

  @@unique([questionLogId, extractionVersion, extractionNumber], name: "unique_extraction_version_number")
  @@index([questionLogId])
  @@index([extractedAt])
  @@index([extractionVersion])
  @@index([overallQuality])
  @@map("question_log_analyses")
}

model ExtractedEntity {
  id         String              @id @db.Uuid
  analysisId String              @map("analysis_id") @db.Uuid
  analysis   QuestionLogAnalysis @relation(fields: [analysisId], references: [id], onDelete: Cascade)

  type            String
  name            String
  normalizedLabel String @map("normalized_label")
  confidence      String
  source          String

  createdAt DateTime @default(now()) @map("created_at")

  @@index([analysisId])
  @@index([type])
  @@index([normalizedLabel])
  @@index([confidence])
  @@index([type, confidence])
  @@index([type, normalizedLabel])
  @@map("extracted_entities")
}
